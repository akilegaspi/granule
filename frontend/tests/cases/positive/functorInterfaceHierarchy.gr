interface Functor (f : Type -> Type) where
  map : forall {a : Type, b : Type} . (a -> b) [] -> (f a) [] -> f b

interface {Functor f} => Applicative (f : Type -> Type) where
  pure : forall {a : Type} . a [] -> f (a []);
  ap : forall {a : Type, b : Type} . f ((a -> b) []) -> (f a) [] -> f b

interface {Applicative m} => Monad (m : Type -> Type) where
  bind : forall {a : Type, b : Type} . m a -> (a -> m b) [] -> m b

liftA : forall {a : Type, b : Type, f : Type -> Type} . {Applicative f} => (a -> b) [] -> (f a) [] -> f b
liftA [f] [x] = ap (pure [f]) [x]

id : forall {a : Type} . a -> a
id x = x

join : forall {m : Type -> Type, a : Type} . {Monad m} => m (m a) -> m a
join m = bind m [id]

data Maybe a = Nothing | Just a

instance Functor Maybe where
  map [f] [Just x] = Just (f x);
  map [f] [x] = Nothing

instance Applicative Maybe where
  pure = Just;
  ap (Just f) x = map f x;
  ap Nothing [_] = Nothing

instance Monad Maybe where
  bind Nothing [_]  = Nothing;
  bind (Just x) [f] = f x

data Either e a = Left e | Right a

instance Functor (Either e) where
  map [f] [Left x] = Left x;
  map [f] [Right x] = Right (f x)

instance Applicative (Either e) where
  pure = Right;
  ap (Right f) x = map f x;
  ap (Left x) [_] = Left x

instance Monad (Either e) where
  bind (Left x) [_] = Left x;
  bind (Right x) [f] = f x
